import { Bot } from "../bot.ts";
import { Message } from "../types/messages/message.ts";
import { CHANNEL_MENTION_REGEX } from "../util/constants.ts";

export function transformMessage(
  bot: Bot,
  data: Message
  ) {
  return {
    // UNTRANSFORMED STUFF HERE
    content: data.content || "",
    isBot: data.author.bot || false,
    tag: `${data.author.username}#${data.author.discriminator.toString().padStart(4, "0")}`,
    timestamp: Date.parse(data.timestamp),
    editedTimestamp: data.editedTimestamp ? Date.parse(data.editedTimestamp) : undefined,
    bitfield:
      (data.tts ? 1n : 0n) |
      (data.mentionEveryone ? 2n : 0n) |
      (data.pinned ? 4n : 0n),
    attachments: data.attachments,
    embeds: data.embeds,
    reactions: data.reactions,
    type: data.type,
    activity: data.activity,
    application: data.application,
    flags: data.flags,
    interaction: data.interaction,
    thread: data.thread,
    components: data.components,
    stickerItems: data.stickerItems,

    // TRANSFORMED STUFF BELOW
    id: bot.transformers.snowflake(data.id),
    guildId: data.guildId ? bot.transformers.snowflake(data.guildId) : undefined,
    channelId: bot.transformers.snowflake(data.channelId),
    webhookId: data.webhookId ? bot.transformers.snowflake(data.webhookId) : undefined,
    authorId: bot.transformers.snowflake(data.author.id),
    applicationId: data.applicationId ? bot.transformers.snowflake(data.applicationId) : undefined,
    messageReference: data.messageReference ? {
      messageId: data.messageReference.messageId ?  bot.transformers.snowflake(data.messageReference.messageId) : undefined,
      channelId: data.messageReference.channelId ?  bot.transformers.snowflake(data.messageReference.channelId) : undefined,
      guildId: data.messageReference.guildId ?  bot.transformers.snowflake(data.messageReference.guildId) : undefined,
    } : undefined,
    mentionedUserIds: data.mentions.map((m) => bot.transformers.snowflake(m.id)),
    mentionedRoleIds: data.mentionRoles.map((id) => bot.transformers.snowflake(id)),
    mentionedChannelIds: [
      // Keep any ids tht discord sends
      ...data.mentionChannels.map((m) => bot.transformers.snowflake(m.id)),
      // Add any other ids that can be validated in a channel mention format
      ...(data.content?.match(CHANNEL_MENTION_REGEX) || []).map((text) =>
        // converts the <#123> into 123
        bot.transformers.snowflake(text.substring(2, text.length - 1))
      ),
    ]
  }
}

export interface DiscordenoMessage
  extends Omit<
    Message,
    | "id"
    | "webhookId"
    | "timestamp"
    | "editedTimestamp"
    | "guildId"
    | "channelId"
    | "member"
    | "author"
    | "applicationId"
    | "thread"
  > {
  id: bigint;
  /** Whether or not this message was sent by a bot */
  isBot: boolean;
  /** The username#discrimnator for the user who sent this message */
  tag: string;
  /** Holds all the boolean toggles. */
  bitfield: bigint;

  // For better user experience

  /** Id of the guild which the massage has been send in. "0n" if it a DM */
  guildId: bigint;
  /** id of the channel the message was sent in */
  channelId: bigint;
  /** If the message is generated by a webhook, this is the webhook's id */
  webhookId?: bigint;
  /** The id of the user who sent this message */
  authorId: bigint;
  /** If the message is a response to an Interaction, this is the id of the interaction's application */
  applicationId?: bigint;
  /** The message content for this message. Empty string if no content was sent like an attachment only. */
  content: string;
  /** Ids of users specifically mentioned in the message */
  mentionedUserIds: bigint[];
  /** Ids of roles specifically mentioned in this message */
  mentionedRoleIds: bigint[];
  /** Channels specifically mentioned in this message */
  mentionedChannelIds?: bigint[];
  /** When this message was sent */
  timestamp: number;
  /** When this message was edited (or undefined if never) */
  editedTimestamp?: number;
}
